# Core_Java_Interview_Questions_And_Answers
### 240 ОСНОВНЫХ ВОПРОСОВ И ОТВЕТОВ НА ИНТЕРВЬЮ ПО JAVA

#### 1) Что такое статические блоки и статические инициализаторы в Java?
Статические блоки или статические инициализаторы используются для инициализации статических полей в **java**. Мы объявляем статические блоки, когда хотим инициализировать статические поля в нашем классе. Статические блоки выполняются ровно один раз при загрузке класса. Статические блоки выполняются еще до выполнения конструкторов.

#### 2) Как вызвать один конструктор из другого конструктора?
В том же классе, если мы хотим вызвать один конструктор из другого, мы используем метод **this()**. В зависимости от количества параметров, которые мы передаем, вызывается соответствующий метод **this()**.
Ограничения на использование этого метода:
1) это должен быть первый оператор в конструкторе
2) мы не можем использовать два метода **this()** в конструкторе

#### 3) Что такое переопределение метода в Java?
Если у нас есть методы с одинаковой сигнатурой (то же имя, та же сигнатура, тот же тип возвращаемого значения) в суперклассе и подклассе, мы говорим, что метод подкласса переопределяется суперклассом. 
Когда использовать переопределение в Java - если нам нужен один и тот же метод с разным поведением в суперклассе и подклассе, мы делаем переопределение. Когда мы вызываем переопределенный метод со ссылкой на подкласс, вызывается метод подкласса, а не метод суперкласса.

#### 4) Что такое ключевое слово super в Java?
Переменные и методы суперкласса могут быть переопределены в подклассе. В случае переопределения объект подкласса вызывает свои собственные переменные и методы. Подкласс не может получить доступ к переменным и методам суперкласса, потому что переопределенные переменные или методы скрывают методы и переменные суперкласса. Но все же **java** предоставляет способ доступа к членам суперкласса, даже если его члены переопределены. **Super** используется для доступа к переменным суперкласса, методам, конструкторам.
Супер может использоваться в двух формах:
1) Первая форма предназначена для вызова конструктора суперкласса.
2) Второй - вызывать переменные суперкласса, методы. **Super**, если он присутствует, должен быть первым оператором.

#### 5) Разница между перегрузкой метода (Overloading) и переопределением (Overriding) метода в Java?
| Перегрузка метода |	Переопределение метода |
| :---:         |     :---:      |
| Перегрузка метода происходит в том же классе	| Переопределение метода происходит между обоими классами (суперкласс и подкласс) |
| Так как он связан только с одним классом, наследование не задействовано	| Переопределение метода происходит между суперклассом и наследованием подкласса |
| При перегрузке возвращаемый тип не обязательно должен быть одинаковым	| При переопределении возвращаемый тип должен быть одинаковым |
| Параметры должны быть другими, когда мы делаем перегрузку	| Параметры должны быть одинаковыми |
| С помощью перегрузки методов может быть достигнут статический полиморфизм	| С помощью переопределения методов может быть достигнут динамический полиморфизм |
| При перегрузке один метод не может скрыть другой	| При переопределении метода подкласса скрывает метод суперкласса |

#### 6) Разница между абстрактным классом (Abstract Class) и интерфейсом (Interface)?
| Интерфейс | Абстрактный класс | 
| :---:         |     :---:      | 
| Интерфейс содержит только абстрактные методы   | Абстрактный класс может содержать абстрактные методы, конкретные методы или оба варианта     | 
| Спецификаторы доступа для методов в интерфейсе должны быть общедоступными (public)     | Кроме public мы можем иметь любой спецификатор доступа для методов в абстрактном классе       | 
| Определенные переменные должны быть public , static , final   | Кроме public переменных могут быть любые спецификаторы доступа     | 
| Множественное наследование в Java реализовано через интерфейс     | Мы не можем добиться множественного наследования, используя абстрактный класс       |
| Для реализации интерфейса мы используем ключевое слово implements   | Для реализации абстрактного класса мы используем ключевое слово extends     | 


#### 7) Почему Java не зависит от платформы?
Самая уникальная особенность **Java** — независимость от платформы. В любом языке программирования исходный код компилируется в исполняемый код. Это не может быть запущено на всех платформах. Когда **javac** компилирует java-программу, он создает исполняемый файл с именем **.class** file.
class файл содержит байтовые коды. Байт-коды интерпретируются только **JVM**. Поскольку эти **JVM** доступны для всех платформ *Sun Microsystems*, мы можем выполнять этот байт-код на любой платформе. Байт-код, созданный в среде *Windows*, также может быть выполнен в среде *Linux*. Это делает платформу **Java** независимой.

#### 8) Что такое перегрузка методов в Java?
Класс, имеющий два или более метода с одинаковым именем, но с разными аргументами, мы говорим, что эти методы перегружены. Статический полиморфизм достигается в **Java** с помощью перегрузки методов.
Перегрузка методов используется, когда мы хотим, чтобы методы выполняли аналогичные задачи, но с разными входными данными или значениями. Когда вызывается перегруженный метод, **Java** сначала проверяет имя метода и количество аргументов, тип аргументов, на основе этого компилятор выполняет этот метод.
Компилятор решает, какой метод вызывать во время компиляции. 

Примечание. Тип возвращаемого значения не является частью сигнатуры метода. у нас могут быть методы с разными типами возвращаемого значения, но одного типа возвращаемого значения недостаточно для вызова метода в **Java**.

#### 9) В чем разница между С++ и Java?
| Java | С++ |
| :---:         |     :---:      | 
| не зависит от платформы | зависит от платформы |
| нет указателей | есть указатели |
| нет перегрузки оператора | имеет перегрузку операторов |
| есть сборка мусора | вывоза мусора нет |
| поддерживает многопоточность |не поддерживает многопоточность |
| нет шаблонов | есть шаблоны |
| нет глобальных переменных | есть глобальные переменные |

#### 10) Что такое JIT-компилятор?
Компилятор **JIT** расшифровывается как компилятор *Just in time*. Компилятор **JIT** компилирует байтовый код в исполняемый код. **JIT часть JVM**. **JIT** не может преобразовать полную Java-программу в исполняемый код, он преобразует по мере необходимости во время выполнения.

#### 11) Что такое байт-код в Java?
Когда компилятор компилятора **javac** компилирует класс, он генерирует файл **.class**. Этот файл **.class** содержит набор инструкций, называемый байтовым кодом. Байт-код является машинно-независимым языком и содержит набор инструкций, которые должны выполняться только **JVM**. **JVM** может понимать эти байтовые коды.

#### 12) Разница между this() и super() в java?
**this()** используется для доступа к одному конструктору из другого в том же классе, а **super()** используется для доступа к конструктору суперкласса. Либо **this()**, либо **super()** существуют должны быть первым оператором в конструкторе.

#### 13) Что такое класс?
Классы являются фундаментальной или базовой единицей объектно-ориентированного программирования. Класс является своего рода планом или шаблоном для объектов. Класс определяет переменные, методы. Класс сообщает, какой тип объектов мы создаем. Например, возьмем класс отдела, который говорит нам, что мы можем создавать объекты типа отдела. Мы можем создать любое количество объектов отдела.
Все программные конструкции в **java** находятся в классе. Когда **JVM** начинает работать, она сначала ищет класс при компиляции. Каждое Java-приложение должно иметь как минимум один класс и один основной метод.
Класс начинается с ключевого слова **class**. Определение класса должно быть сохранено в файле класса, имя которого совпадает с именем класса. Имя файла должно заканчиваться расширением **.java**.
```
public class FirstClass {
  public static void main(String[] args) {
    System.out.println(“My First class”);
  }
}
```
Если мы видим вышеуказанный класс при компиляции, JVM загружает FirstClass и создает файл .class (FirstClass.class). Когда мы запускаем программу, мы запускаем класс, а затем выполняем основной метод.

#### 14) Что такое объект?
Объект является экземпляром класса. Класс определяет тип объекта. Каждый объект принадлежит некоторому классу. Каждый объект содержит состояние и поведение. Состояние определяется значением атрибутов, а поведение называется методом. Объекты также называются экземплярами.
Чтобы создать экземпляр класса, мы объявляем тип класса.
```
public classFirstClass {
  public static voidmain(String[] args) {
    FirstClass f=new FirstClass(); 
    System.out.println(“My First class”);
  }
}
```
Чтобы создать экземпляр **FirstClass**, мы используем этот оператор
FirstClass f=new FirstClass();
f используется для ссылки на объект FirstClass.

#### 15) Что такое метод в Java?
Метод содержит исполняемое тело, которое можно применить к конкретному объекту класса.
Метод включает имя метода, параметры или аргументы, тип возвращаемого значения и тело исполняемого кода.
пример: **public float add(int a, int b, int c)**
методы могут иметь несколько аргументов разделённые запятыми.

#### 16) Что такое инкапсуляция?

> Процесс упаковки или размещения данных в одном классе и защита данных от неправильного использования называется инкапсуляцией.

Благодаря инкапсуляции мы можем скрывать и защищать данные, хранящиеся в объектах **Java**. **Java** поддерживает инкапсуляцию посредством контроля доступа. В **Java** есть четыре модификатора управления доступом: **public**, **private**, **protected** и **default (package visible)**.
Например, возьмем класс автомобиля. В автомобиле у нас есть много частей, которые не требуются водителю, чтобы знать, что все это внутри. От него требуется знать только о том, как заводить и останавливать машину. Таким образом, мы можем раскрыть то, что требуется, и скрыть остальное, используя инкапсуляцию.

#### 17) Почему метод main() public, static и void в java?
**public**: *«public»* — это спецификатор доступа, который можно использовать вне класса. Когда основной метод объявлен общедоступным, это означает, что его можно использовать вне класса.
**static**: для вызова метода нам требуется объект. Иногда может потребоваться вызвать метод без помощи объекта. Затем мы объявляем этот метод как статический. **JVM** вызывает метод **main()** без создания объекта, объявляя ключевое слово **static**.
**void**: тип возвращаемого значения **void** используется, когда метод не возвращает никакого значения. Метод **main()** не возвращает никакого значения, поэтому **main()** объявлен как **void**.


